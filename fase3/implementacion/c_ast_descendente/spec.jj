options  {
  STATIC=false;
  DEBUG_PARSER=true;
}  
PARSER_BEGIN(AnalizadorSintacticoTiny)
package c_ast_descendente;
import asint.ClaseSemanticaTiny;
import errors.GestionErroresTiny;
import asint.SintaxisAbstractaTiny.Bloq;
import asint.SintaxisAbstractaTiny.SecDecs;
import asint.SintaxisAbstractaTiny.LDecs;
import asint.SintaxisAbstractaTiny.Dec;
import asint.SintaxisAbstractaTiny.SecIs;
import asint.SintaxisAbstractaTiny.LIs;
import asint.SintaxisAbstractaTiny.I;
import asint.SintaxisAbstractaTiny.ParamFs;
import asint.SintaxisAbstractaTiny.LParamFs;
import asint.SintaxisAbstractaTiny.ParamF;
import asint.SintaxisAbstractaTiny.ParamRs;
import asint.SintaxisAbstractaTiny.LParamRs;
import asint.SintaxisAbstractaTiny.LCampos;
import asint.SintaxisAbstractaTiny.TipoNom;
import asint.SintaxisAbstractaTiny.Tipo;
import asint.SintaxisAbstractaTiny.Exp;
import asint.SintaxisAbstractaTiny.Prog;

public class AnalizadorSintacticoTiny {
   private ClaseSemanticaTiny sem = new ClaseSemanticaTiny();   
}
PARSER_END(AnalizadorSintacticoTiny)

  TOKEN:{<#letra:["A"-"Z","a"-"z"]>}
  TOKEN:{<#digitoPositivo:["1"-"9"]>}
  TOKEN:{<#digito:<digitoPositivo>|"0">} 
  TOKEN:{<#parteEntera:("+"|"-")? <digitoPositivo> (<digito>)* | "0">} 
  TOKEN:{<#parteDecimal: (<digito>)* <digitoPositivo> | "0">}
  TOKEN:{<#parteExponencial: ("e"|"E")<parteEntera>>}
  SKIP:{<["\t"," ","\r","\b","\n"]>}  
  SKIP:{<"##"(~["\n"])*>}
  TOKEN:{<bool:("b"|"B")("o"|"O")("o"|"O")("l"|"L")>} 
  TOKEN:{<INT:("i"|"I")("n"|"N")("t"|"T")>}  
  TOKEN:{<real:("r"|"R")("e"|"E")("a"|"A")("l"|"L")>}
  TOKEN:{<string:("s"|"S")("t"|"T")("r"|"R")("i"|"I")("n"|"N")("g"|"G")>}
  TOKEN:{<and:("a"|"A")("n"|"N")("d"|"D")>}
  TOKEN:{<or:("o"|"O")("r"|"R")>}
  TOKEN:{<not:("n"|"N")("o"|"O")("t"|"T")>}
  TOKEN:{<TRUE:("t"|"T")("r"|"R")("u"|"U")("e"|"E")>}
  TOKEN:{<FALSE:("f"|"F")("a"|"A")("l"|"L")("s"|"S")("e"|"E")>}
  TOKEN:{<NULL:("n"|"N")("u"|"U")("l"|"L")("l"|"L")>}
  TOKEN:{<proc:("p"|"P")("r"|"R")("o"|"O")("c"|"C")>}
  TOKEN:{<IF:("i"|"I")("f"|"F")>}
  TOKEN:{<ELSE:("e"|"E")("l"|"L")("s"|"S")("e"|"E")>}
  TOKEN:{<WHILE:("w"|"W")("h"|"H")("i"|"I")("l"|"L")("e"|"E")>}
  TOKEN:{<struct:("s"|"S")("t"|"T")("r"|"R")("u"|"U")("c"|"C")("t"|"T")>}
  TOKEN:{<NEW:("n"|"N")("e"|"E")("w"|"W")>}
  TOKEN:{<delete:("d"|"D")("e"|"E")("l"|"L")("e"|"E")("t"|"T")("e"|"E")>}
  TOKEN:{<read:("r"|"R")("e"|"E")("a"|"A")("d"|"D")>}
  TOKEN:{<write:("w"|"W")("r"|"R")("i"|"I")("t"|"T")("e"|"E")>}
  TOKEN:{<nl:("n"|"N")("l"|"L")>}
  TOKEN:{<type:("t"|"T")("y"|"Y")("p"|"P")("e"|"E")>}
  TOKEN:{<call:("c"|"C")("a"|"A")("l"|"L")("l"|"L")>}
  TOKEN:{<literalEntero:<parteEntera>>}
  TOKEN:{<literalReal:<parteEntera>("."<parteDecimal>|<parteExponencial>|"."<parteDecimal><parteExponencial>)>}
  TOKEN:{<identificador:("_"|<letra>)(<letra>|<digito>|"_")*>}
  TOKEN:{<literalCadena:"\""(~["\""])*"\"">}

  TOKEN:{<suma:("+")>}
  TOKEN:{<resta:("-")>}
  TOKEN:{<mul:("*")>}
  TOKEN:{<div:("/")>}
  TOKEN:{<mod:("%")>}
  TOKEN:{<menor:("<")>}
  TOKEN:{<mayor:(">")>}
  TOKEN:{<igual:("==")>}
  TOKEN:{<distinto:("!=")>}
  TOKEN:{<menorIgual:("<=")>}
  TOKEN:{<mayorIgual:(">=")>}
  TOKEN:{<asig:("=")>}
  TOKEN:{<finalAsig:("&&")>}
  TOKEN:{<parenApert:("(")>}
  TOKEN:{<parenCierre:(")")>}
  TOKEN:{<llaveApert:("{")>}
  TOKEN:{<llaveCierre:("}")>}
  TOKEN:{<puntoComa:(";")>}
  TOKEN:{<coma:(",")>}
  TOKEN:{<punto:(".")>}
  TOKEN:{<arroba:("@")>}
  TOKEN:{<indireccion:("^")>}
  TOKEN:{<paramRef:("&")>}
  TOKEN:{<corcheteApert:("[")>}
  TOKEN:{<corcheteCierre:("]")>}
  
  Prog analiza()   : 
      {Prog prog;} {
         prog = programa() <EOF> {return prog;} 
      }
  
  Prog programa()  : 
    {Bloq bloq;} {
        bloq = bloque() {return sem.prog(bloq);}
    }
  
  Bloq bloque()  : 
	{SecDecs secdecs; SecIs secis;} {
		<llaveApert>
		secdecs = seccion_declaraciones_opt()
		secis = seccion_instrucciones_opt()
		<llaveCierre>
		{return sem.bloq(secdecs, secis);}
	}
  
  SecDecs seccion_declaraciones_opt()  : 
	{LDecs ldecs;} {
		ldecs = seccion_declaraciones() <finalAsig> {return sem.si_decs(ldecs);}
		| {return sem.no_decs();}
	}
  LDecs seccion_declaraciones()  : 
	{Dec dec; LDecs r;} {
		dec = declaracion() r = resto_sd(sem.una_dec(dec)) {return r;}
	}
  LDecs resto_sd(LDecs rh)  : 
	{Dec dec; LDecs r;} {
		<puntoComa> dec = declaracion() r = resto_sd(sem.muchas_decs(rh, dec)) {return r;}
		| {return rh;}
	}
  Dec declaracion()  : 
	{TipoNom tiponom; Token id; ParamFs p; Bloq bloq;} {
		tiponom = tipo_nombre() {return sem.dec_base(tiponom);}
		| <type> tiponom = tipo_nombre() {return sem.dec_type(tiponom);}
		| <proc> id = <identificador> p = parametros_formales() bloq = bloque()
			{return (Dec)sem.dec_proc(id.image, p, bloq).ponFila(id.beginLine).ponCol(id.beginColumn);}
	}
  ParamFs parametros_formales()  : 
	{ ParamFs l; } {
		<parenApert> l = lista_parametros_opt() <parenCierre>
		{ return l; }
	}
  ParamFs lista_parametros_opt()  : 
	{ LParamFs l; } {
		l = lista_parametros() { return sem.si_params_f(l); }
		| { return sem.no_params_f(); }
	}
  LParamFs lista_parametros()  : 
	{ ParamF p; LParamFs l; } {
		p = parametro() l = resto_lp(sem.un_param_f(p)) { return l; }
	}
  LParamFs resto_lp(LParamFs lp0)  : 
	{ ParamF p; LParamFs lp1; } {
		<coma> p = parametro() lp1 = resto_lp(sem.muchos_params_f(lp0, p)) { return lp1; }
		| { return lp0; }
	}
  ParamF parametro()  : 
	{ Tipo t; ParamF p; } {
		t = tipo() p = resto_parametro(t) { return p; }
	}  
  ParamF resto_parametro(Tipo t)  : 
	{ Token i; } {
		<paramRef> i = <identificador> { return sem.si_refparam_f(t, i.image); }
		| i = <identificador> { return sem.no_refparam_f(t, i.image); }
	}  
  
  TipoNom tipo_nombre()  : 
	{Tipo t; Token i;} {
		t = tipo() i = <identificador>
		{return sem.tipo_nombre(t, i.image);}
	}  
  Tipo tipo()  : 
	{Tipo t;} {
		t = tipo0() { return t; }
	}  
  Tipo tipo0()  : 
	{ Tipo t0, t1; } {
		t0 = tipo1() t1 = resto_tipo0(t0) { return t1; }
	}  
  Tipo resto_tipo0(Tipo t0)  : 
	{ Token i; Tipo t1; } {
		<corcheteApert> i = <literalEntero> <corcheteCierre>
		t1 = resto_tipo0(sem.tipo_array(t0, i.image))
		{ return t1; }
		| { return t0; }
	}  
  Tipo tipo1() : 
	{ Tipo t; } {
		<indireccion> t = tipo1() { return sem.tipo_indir(t); }
		| t = tipo_base() { return t; }
	}  
  Tipo tipo_base()  : 
	{ LCampos l; Token i; } {
		<struct> <llaveApert> l = lista_campos() <llaveCierre> { return sem.tipo_struct(l); }
		| <INT>  { return sem.tipo_int(); }
		| <real>  { return sem.tipo_real(); }
		| <bool>  { return sem.tipo_bool(); }
		| <string>  { return sem.tipo_string(); }
		| i = <identificador> { return sem.tipo_type(i.image); }
	}  
  LCampos lista_campos()  : 
	{ TipoNom tn; LCampos l; } {
		tn = tipo_nombre() l = resto_lc(sem.un_campo(tn))
		{ return l; }
	}  
  LCampos resto_lc(LCampos lc0)  : 
	{ TipoNom tn; LCampos lc1; } {
		<coma> tn = tipo_nombre() lc1 = resto_lc(sem.muchos_campos(lc0, tn)) { return lc1; }
		| { return lc0; }
	}  
  
  SecIs seccion_instrucciones_opt()  : 
	{ LIs li; } {
		li = seccion_instrucciones()  { return sem.si_ins(li); }
		| { return sem.no_ins(); }
	}  
  LIs seccion_instrucciones()  : 
	{ LIs li; } {
		li = lista_instrucciones() { return li; }
	}  
  LIs lista_instrucciones()  : 
	{ I i; LIs li; } {
		i = instruccion() li = resto_li(sem.una_ins(i)) { return li; }
	}  
  LIs resto_li(LIs li0)  : 
	{ I i; LIs li1; } {
		<puntoComa> i = instruccion() li1 = resto_li(sem.muchas_ins(li0, i))  { return li1; }
		| { return li0; }
	}  
  I instruccion()  : 
	{ Exp e; Bloq b; I i, i1; Token tk; ParamRs pr; } {
		<arroba> e = expresion()  { return sem.ins_eval(e); }
		| i = if_ins() i1 = resto_ii(i) { return i1; }
		| <WHILE> e = expresion() b = bloque() { return sem.ins_while(e, b); }
		| <read> e = expresion() { return sem.ins_read(e); }
		| <write> e = expresion()  { return sem.ins_write(e); }
		| <nl> { return sem.ins_nl(); }
		| <NEW> e = expresion() { return sem.ins_new(e); }
		| <delete> e = expresion() { return sem.ins_delete(e); }
		| <call> tk = <identificador> pr = parametros_reales() { return sem.ins_call(tk.image, pr); }
		| b = bloque() { return sem.ins_bloque(b); }
	}  
  I resto_ii(I i0)  :
	{ I i1; } {
		i1 = else_ins(i0) { return i1; }
  		| { return i0; }
	}    
  I if_ins()  :
  	{ Exp e; Bloq b; } {
		<IF> e = expresion() b = bloque() { return sem.ins_if(e, b); }
	}  
  I else_ins(I i)  :
  	{ Bloq b; } {
		<ELSE> b = bloque() { return sem.ins_if_else(i, b); }
	}
  ParamRs parametros_reales()  :
	{ParamRs l;} {
		<parenApert> l = lista_expresiones_opt() <parenCierre> { return l; }
	}  
  ParamRs lista_expresiones_opt()  :
	{LParamRs l;} {
		l = lista_expresiones() {return sem.si_params_r(l); }
		| { return sem.no_params_r(); }
	}    
  LParamRs lista_expresiones()  :
  	{ Exp e0; LParamRs lp; } {
		e0 = expresion() lp = resto_le(sem.un_param_r(e0)) { return lp; }
	}
  LParamRs resto_le(LParamRs p0)  :
  	{Exp e0; LParamRs lp; } {
		<coma> e0 = expresion() lp = resto_le(sem.muchos_params_r(p0, e0)) { return lp; }
		| { return p0; }
	}  
  
  Exp expresion()  : { Exp e; } {e = E0() { return e; }}  
  Exp E0()  : {Exp e0, e1; } {e0 = E1() e1 = resto_E0(e0) { return e1; } }  
  Exp resto_E0(Exp e0)  : { Exp e1; } {<asig> e1 = E0() { return sem.mkopbin("=", e0, e1); } | { return e0; } }    
  Exp E1()  : { Exp e0, e1; } {e0 = E2() e1 = resto_E1(e0) {return e1;} }  
  Exp resto_E1(Exp e0)  : { String op; Exp e1, e2; } {op = op_relacional() e1 = E2() e2 = resto_E1(sem.mkopbin(op, e0, e1)) { return e2; } | { return e0; }}  
  Exp E2()  : { Exp e0, e1, e2; } { e0 = E3() e1 = resto_E2_F(e0) e2 = resto_E2_R(e1) { return e2; } }   
  Exp resto_E2_R(Exp e0)  : { Exp e1, e2; } {<suma> e1 = E3() e2 = resto_E2_R(sem.mkopbin("+", e0, e1)) {return e2;} | {return e0;}}  
  Exp resto_E2_F(Exp e0)  : {Exp e1;} {<resta> e1 = E3() {return sem.mkopbin("-", e0, e1);} | { return e0; }} 
  Exp E3()  : {Exp e0, e1;} {e0 = E4() e1 = resto_E3(e0) {return e1;}}  
  Exp resto_E3(Exp e0)  : {Exp e1;} {
	<and> e1 = E3() {return sem.mkopbin("and", e0, e1);}
	| <or> e1 = E4() {return sem.mkopbin("or", e0, e1);}
	| {return e0;}
	}
  Exp E4()  : {Exp e0, e1;} {e0 = E5() e1 = resto_E4(e0) {return e1;} }
  Exp resto_E4(Exp e0)  : {String op; Exp e1, e2;} {op = op_mult() e1 = E5() e2 = resto_E4(e1) {return e2;} | {return e0;}}  
  Exp E5()  : {Exp e0;} {
	<resta> e0 = E5() {return sem.mkopun("-", e0);}
	| <not> e0 = E5() {return sem.mkopun("not", e0);}
	| e0 = E6() {return e0;}}
  Exp E6()  : {Exp e0, e1;} { e0 = E7() e1 = resto_E6(e0) {return e1;} }
  Exp resto_E6(Exp e0)  : { Exp e1, e2; Token i; } {
	<indireccion> e1 = resto_E6(sem.exp_indir(e0)) { return e1; }
	| <punto> i = <identificador> e1 = resto_E6(sem.exp_reg(e0, i.image)) { return e1; }
	| <corcheteApert> e1 = expresion() <corcheteCierre> e2 = resto_E6(sem.exp_index(e0, e1)) { return e2; }
	| { return e0; } }
  Exp E7()  : {Exp e0;} {
	e0 = expresion_basica() { return e0; }
	| <parenApert> e0 = E0() <parenCierre> { return e0; } }
  Exp expresion_basica()  :
  	{ Token i; } {
		i = <literalEntero> { return sem.exp_entero(i.image); }
		| i = <literalReal> { return sem.exp_real(i.image); }
		| <TRUE> { return sem.exp_true(); }
		| <FALSE> { return sem.exp_false(); }
		| i = <literalCadena> { return sem.exp_entero(i.image); }
		| i = <identificador> { return sem.exp_iden(i.image); }
		| i = <NULL> { return sem.exp_null(); }
	}  
  
  String op_relacional()  : { Token i; } {
	i = <menor> { return i.image; }
	| i = <menorIgual> { return i.image; }
	| i = <mayor> { return i.image; }
	| i = <mayorIgual> { return i.image; }
	| i = <igual> { return i.image; }
	| i = <distinto> { return i.image; }
	}    
  String op_mult()  : { Token i; } {
	i = <mul> { return i.image; }
	| i = <div> { return i.image; }
	| i = <mod> { return i.image; } }  